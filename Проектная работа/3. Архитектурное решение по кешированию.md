# Мотивация

Каждый раз, когда пользователи обращается за каким-либо ресурсом, система может обращаться к базе данных или даже запускает сложные вычисления.  
Кэширование позволяет сохранять ранее сгенерированные результаты запросов, чтобы последующие запросы могли быстро получать готовые данные из кэша. 
Это сокращает время загрузки, особенно для часто запрашиваемых данных или редко обновляемых, но требующих большого количества ресурсов для калькуляции.  
Кэширование помогает лучше масштабировать систему, так как часть запросов обрабатывается быстрее, что улучшает производительность при увеличении нагрузки.   
Даже при большом числе пользователей кэшированные данные позволяют системе выдерживать больше одновременных запросов.  
Кэширование позволяет избежать дублирования сложных вычислений. Например, не пересчитывать стоимость для 3D модели, которая не изменилась, тем самым избежать лишней бесполезной нагрузки 
на MES компонент

# Предлагаемое решение

Для улучшения пользовательского опыта работы с интернет-магазином возможно реализовать кэширование на стороне клиента, то есть клиентского браузера.
Пользователь в основном запрашивает информацию о статусах своих заказов, которые меняются не так часто, поэтому можно закэшировать эти данные на клиенте тем самым уменьшив количество запросов к внутренним подсистемам 
за информацией.

Наибольшую проблему составляет компонент MES и его дашборд, даже после добавления фильтрации и пагинации. Каждый оператор запрашивает список заказов, для того чтобы взять в работу. Этот список в большинстве случаев будет 
содержать одну и ту же информацию, поэтому видится эти данные хорошо поддаются кэшированию.

Существует еще один аспект при работе с MES. С открытием MES API для сторонних пользователей, у них появилась возможность необоснованно нагружать систему на просчет стоимости изделия, тем самым 
утилизируя ресурсы и время. Возможно в данном случае было бы полезно применение подхода Rate Limiter для запросов на MES и/или MES API со стороны внешних пользователей.

Таким образом, видится что, внедрение кэширования с соответствующими подходами целесообразно применить для следующих компонент.

**Клиентское кэширование в браузере**
Кэшируем ответ с заказами, инвалидируя его с использованием заголовков `max-age` и `Cache-Control: no-cache`.   
Если клиент на очередной запрос получит устаревшие данные по статусам заказов, при этом время хранения этих данных в кэше будет адекватным, то кажется что это нормальная ситуация. 
Время изменения статуса заказа с условного "Взят в работу" до "Выполнен" измеряется часами, поэтому мы вполне может кешировать такие данные.

**Кэширование данных расчета стоимости**
Для того, чтобы не нагружать MES компонент идентичными задачами на просчет стоимости, можно кэшировать результат предыдущей итерации. Для этого будем использовать `Read-Through` & `Write-Through` 
поход, в котором сохранение результатов просчета делается единожды, т.е. операций записи будет крайне мало.

**Кэширование дашборда заказов**
Операторы открывают один и тот же дашборд, с одними и теми же заказами, выбирая какой взять в работу. В данном случае также будем применять подход `Read-Through` & `Write-Through`, чтобы БД самостоятельно обновляла 
кэш наиболее актуальными и новыми заказами. В данном случае предпочтительнее использовать именно синхронный `Write-Through` для избегания ситуации когда два оператора смогут взять один и тот же заказ. Инвалидировать данные можно как по ключу заказа, 
так и по изменению его состояния.

Возможно использование кэша целесообразно и для других компонент системы, но это необходимо внимательно анализировать на основе данных полученных из системы мониторинга, анализируя задержки в ответах.


**Диаграмма последовательностей чтения списка заказов и изменения статуса**
Сущность заказа будем считать мастер-данными системы, которые будут храниться в базе данных CRM (Internet Shop Database).  

```puml
@startuml
!include https://raw.githubusercontent.com/plantuml-stdlib/C4-PlantUML/master/C4_Sequence.puml

Person(user, "Operator")
Container(mes, "MES", "#NET")
Container(mes_api, "MES API", "SpringBoot")
Container(cache, "Cache", "_")
Container(crm_db, "CRM DB", "PostgreSQL")
Container(rabbit, "RabbitMQ", "Erlang")

Rel(crm_db, cache, "Updates orders cache", "Pass Order entities")
Rel(user, mes, "Clicks on orders page button")
Rel(mes, mes_api, "Requests orders list", "JSON/HTTPS")
Rel(mes_api, cache, "Fetches orders", "JSON/HTTPS")
Rel(cache, mes_api, "Returns orders", "JSON/HTTP")
Rel(mes_api, mes, "Returns orders", "JSON/HTTP")
Rel(mes, user, "Draw list")

Rel(user, mes, "Assigns order")
Rel(mes, mes_api, "Requests to update state", "JSON/HTTPS")
Rel(mes_api, cache, "Saves new state", JSON/HTTPS)
Rel(cache, crm_db, "Writes new state", "SQL")
Rel(crm_db, cache, "Confirm write operation")
Rel(cache, cache, "Updates states")
Rel(cache, mes_api, "Returns result", JSON/HTTPS)
Rel(mes_api, rabbit, "Sends event about state changed")
Rel(mes_api, mes, "Returns write result", JSON/HTTPS)
Rel(mes, user, "Update state", "JSON/HTTP")

SHOW_LEGEND()
@enduml
```